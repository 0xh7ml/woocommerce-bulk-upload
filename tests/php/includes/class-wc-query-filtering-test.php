<?php

use Automattic\WooCommerce\Internal\AttributesHelper;

/**
 * Tests related to filtering for WC_Query.
 */
class WC_Query_Filtering_Test extends \WC_Unit_Test_Case {

	/**
	 * Runs before all the tests in the class.
	 */
	public static function setupBeforeClass() {
		global $wpdb, $wp_post_types;

		parent::setUpBeforeClass();

		$wpdb->query( "DROP TABLE IF EXISTS {$wpdb->prefix}wc_product_attributes_lookup" );
		$wpdb->query(
			"
          CREATE TABLE {$wpdb->prefix}wc_product_attributes_lookup (
		  product_id bigint(20) NOT NULL,
		  product_or_parent_id bigint(20) NOT NULL,
		  taxonomy varchar(32) NOT NULL,
		  term_id bigint(20) NOT NULL,
		  is_variation_attribute tinyint(1) NOT NULL,
		  in_stock tinyint(1) NOT NULL
 		  );
		"
		);

		// This is required too for WC_Query to act on the main query.
		$wp_post_types['product']->has_archive = true;
	}


	/**
	 * Runs after all the tests in the class.
	 */
	public static function tearDownAfterClass() {
		global $wpdb;

		parent::tearDownAfterClass();

		$wpdb->query( "DROP TABLE IF EXISTS {$wpdb->prefix}wc_product_attributes_lookup" );
	}


	/**
	 * Runs after each test.
	 */
	public function tearDown() {
		global $wpdb;

		parent::tearDown();

		$wpdb->query( "TRUNCATE TABLE {$wpdb->prefix}wc_product_attributes_lookup" );

		// Unregister all product attributes.

		$attribute_ids_by_name = wc_get_attribute_taxonomy_ids();
		if ( ! empty( $attribute_ids_by_name ) ) {
			$attribute_names = array_keys( $attribute_ids_by_name );
			foreach ( $attribute_names as $name ) {
				AttributesHelper::remove_taxonomy_for_attribute( $name );
			}
			$this->do_rest_request( 'products/attributes/batch', array( 'delete' => array_values( $attribute_ids_by_name ) ), 'POST' );
		}

		// Remove all products.

		$product_ids = wc_get_products( array( 'return' => 'ids' ) );
		if ( ! empty( $product_ids ) ) {
			$this->do_rest_request( 'products/batch', array( 'delete' => $product_ids ), 'POST' );
		}

		// Force the next query to re-read the filtering attributes from the query parameters.

		WC_Query::reset_chosen_attributes();
	}


	/**
	 * Creates a simple product.
	 *
	 * @param array $attributes An array of product attributes, keys are attribute names, values are arrays of attribute term names.
	 * @param bool  $in_stock True if the poroduct is in stock, false otherwise.
	 * @return array The product data, as generated by the REST API product creation entry point.
	 */
	private function create_simple_product( $attributes, $in_stock ) {
		global $wpdb;

		$converted_attributes  = array();
		$lookup_insert_clauses = array();
		$lookup_insert_values  = array();

		$attribute_ids_by_name = wc_get_attribute_taxonomy_ids();
		foreach ( $attributes as $name => $terms ) {
			$sanitized_name = wc_sanitize_taxonomy_name( $name );
			$attribute_id   = $attribute_ids_by_name[ $sanitized_name ];

			$converted_attributes[] = array(
				'id'      => $attribute_id,
				'options' => $terms,
			);
		}

		$product = $this->do_rest_request(
			'products',
			array(
				'name'          => 'Product',
				'type'          => 'simple',
				'regular_price' => '1',
				'stock_status'  => $in_stock ? 'instock' : 'outofstock',
				'attributes'    => $converted_attributes,
			),
			'POST'
		);

		if ( empty( $attributes ) ) {
			return $product;
		}

		foreach ( $attributes as $name => $terms ) {
			$taxonomy_name     = wc_attribute_taxonomy_name( $name );
			$term_objects      = get_terms( $taxonomy_name );
			$term_ids_by_names = wp_list_pluck( $term_objects, 'term_id', 'name' );

			foreach ( $terms as $term ) {
				$lookup_insert_clauses[] = '(%d, %d, %s, %d, %d, %d )';
				$lookup_insert_values[]  = $product['id'];
				$lookup_insert_values[]  = $product['id'];
				$lookup_insert_values[]  = wc_attribute_taxonomy_name( $name );
				$lookup_insert_values[]  = $term_ids_by_names[ $term ];
				$lookup_insert_values[]  = 0;
				$lookup_insert_values[]  = $in_stock ? 1 : 0;
			}
		}

		// phpcs:disable WordPress.DB.PreparedSQL.NotPrepared

		$insert_query =
			"INSERT INTO {$wpdb->prefix}wc_product_attributes_lookup ( product_id, product_or_parent_id, taxonomy, term_id, is_variation_attribute, in_stock ) VALUES "
			. join( ',', $lookup_insert_clauses );

		$prepared_insert = $wpdb->prepare( $insert_query, $lookup_insert_values );

		$wpdb->query( $prepared_insert );

		// phpcs:enable WordPress.DB.PreparedSQL.NotPrepared

		return $product;
	}

	/**
	 * Create a product attribute.
	 *
	 * @param string $name The attribute name.
	 * @param array  $terms The terms that will be created for the attribute.
	 */
	private function create_product_attribute( $name, $terms ) {
		$result = $this->do_rest_request( 'products/attributes', array( 'name' => $name ), 'POST' );
		$this->get_instance_of( AttributesHelper::class )->create_taxonomy_for_attribute( $name );
		$attribute_id = $result['id'];

		$attribute_ids_by_name[ wc_sanitize_taxonomy_name( $name ) ] = $attribute_id;

		foreach ( $terms as $term ) {
			$this->do_rest_request( "products/attributes/{$attribute_id}/terms", array( 'name' => $term ), 'POST' );
		}
	}


	/**
	 * Set the "hide out of stock products" option.
	 *
	 * @param bool $hide The value to set the option to.
	 */
	private function set_hide_out_of_stock_items( $hide ) {
		update_option( 'woocommerce_hide_out_of_stock_items', $hide ? 'yes' : 'no' );
	}


	/**
	 * Simulate a product query.
	 *
	 * @param array $filters The attribute filters as an array of attribute name => attribute terms.
	 * @param array $query_types The query types for each attribute as an array of attribute name => "or"/"and".
	 * @return mixed
	 */
	private function do_product_request( $filters, $query_types = array() ) {
		global $wp_the_query;

		foreach ( $filters as $name => $values ) {
			$_GET[ 'filter_' . wc_sanitize_taxonomy_name( $name ) ] = join( ',', array_map( 'wc_sanitize_taxonomy_name', $values ) );
		}

		foreach ( $query_types as $name => $value ) {
			$_GET[ 'query_type_' . wc_sanitize_taxonomy_name( $name ) ] = $value;
		}

		return $wp_the_query->query(
			array(
				'post_type' => 'product',
				'fields'    => 'ids',
			)
		);
	}

	/**
	 * @testdox The product query shows a simple product only if it's not filtered out by the specified attribute filters.
	 *
	 * @testWith [[], "and", true]
	 *           [[], "or", true]
	 *           [["Blue"], "and", true]
	 *           [["Blue"], "or", true]
	 *           [["Blue", "Red"], "and", true]
	 *           [["Blue", "Red"], "or", true]
	 *           [["Green"], "and", false]
	 *           [["Green"], "or", false]
	 *           [["Blue", "Green"], "and", false]
	 *           [["Blue", "Green"], "or", true]
	 *
	 * @param array  $attributes The color attribute names that will be included in the query.
	 * @param string $filter_type The filtering type, "or" or "and".
	 * @param bool   $expected_to_be_visible True if the product is expected to be returned by the query, false otherwise.
	 */
	public function test_filtering_simple_product_in_stock( $attributes, $filter_type, $expected_to_be_visible ) {
		$this->create_product_attribute( 'Color', array( 'Blue', 'Red', 'Green' ) );

		$product = $this->create_simple_product(
			array(
				'Color' => array(
					'Blue',
					'Red',
				),
			),
			true
		);

		$filtered_product_ids = $this->do_product_request( array( 'Color' => $attributes ), array( 'Color' => $filter_type ) );

		if ( $expected_to_be_visible ) {
			$this->assertEquals( array( $product['id'] ), $filtered_product_ids );
		} else {
			$this->assertEmpty( $filtered_product_ids );
		}
	}

	/**
	 * @testdox The product query shows a simple product only if it's in stock OR we don't have "hide out of stock items" set.
	 *
	 * @testWith [false, true, true]
	 *           [false, false, true]
	 *           [true, true, true]
	 *           [true, false, false]
	 *
	 * @param bool $hide_out_of_stock The value of the "hide out of stock products" option.
	 * @param bool $is_in_stock True if the product is in stock, false otherwise.
	 * @param bool $expected_to_be_visible True if the product is expected to be returned by the query, false otherwise.
	 */
	public function test_filtering_simple_product_out_of_stock( $hide_out_of_stock, $is_in_stock, $expected_to_be_visible ) {
		$product = $this->create_simple_product(
			array(),
			$is_in_stock
		);

		$this->set_hide_out_of_stock_items( $hide_out_of_stock );

		$filtered_product_ids = $this->do_product_request( array() );

		if ( $expected_to_be_visible ) {
			$this->assertEquals( array( $product['id'] ), $filtered_product_ids );
		} else {
			$this->assertEmpty( $filtered_product_ids );
		}
	}
}
